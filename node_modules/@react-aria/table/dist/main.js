var $ca0f93ae476efcee$exports = require("./ar-AE.main.js");
var $8fcf86b24fd399a9$exports = require("./bg-BG.main.js");
var $146712099a722811$exports = require("./cs-CZ.main.js");
var $2735c96991aebe53$exports = require("./da-DK.main.js");
var $d85ed0c826146b1e$exports = require("./de-DE.main.js");
var $1aecf8df24cd2c6e$exports = require("./el-GR.main.js");
var $8629e38d73986227$exports = require("./en-US.main.js");
var $219ef73190fd7b54$exports = require("./es-ES.main.js");
var $28e4d12b64c559fe$exports = require("./et-EE.main.js");
var $d443cdd0bb14863a$exports = require("./fi-FI.main.js");
var $e7b61bd0e93b97c5$exports = require("./fr-FR.main.js");
var $b09d12ffa0a56a3e$exports = require("./he-IL.main.js");
var $c3d9f76f15300329$exports = require("./hr-HR.main.js");
var $9904561a995a328e$exports = require("./hu-HU.main.js");
var $b63a88a974650d19$exports = require("./it-IT.main.js");
var $f79114b6f7838962$exports = require("./ja-JP.main.js");
var $305e358db516b233$exports = require("./ko-KR.main.js");
var $c37a95c245032ee0$exports = require("./lt-LT.main.js");
var $0d99b6662f72a76d$exports = require("./lv-LV.main.js");
var $b350dd154e1c203e$exports = require("./nb-NO.main.js");
var $94dcc10598f2ecbe$exports = require("./nl-NL.main.js");
var $847263ec44d85feb$exports = require("./pl-PL.main.js");
var $649f25af616381b6$exports = require("./pt-BR.main.js");
var $63863f752f22090b$exports = require("./pt-PT.main.js");
var $1011caef6838d0cf$exports = require("./ro-RO.main.js");
var $5c0e71883f016b2f$exports = require("./ru-RU.main.js");
var $9799788df99a536e$exports = require("./sk-SK.main.js");
var $79bf9bea0e0b8579$exports = require("./sl-SI.main.js");
var $374736afc1a4c11c$exports = require("./sr-SP.main.js");
var $948317bce9061901$exports = require("./sv-SE.main.js");
var $73e2289d5a9ac4de$exports = require("./tr-TR.main.js");
var $aca57efccc60ebb1$exports = require("./uk-UA.main.js");
var $ccd86abad329f871$exports = require("./zh-CN.main.js");
var $ad6eb5efb83fe2f8$exports = require("./zh-TW.main.js");
var $kJQf8$reactariagrid = require("@react-aria/grid");
var $kJQf8$reactarialiveannouncer = require("@react-aria/live-announcer");
var $kJQf8$reactariautils = require("@react-aria/utils");
var $kJQf8$react = require("react");
var $kJQf8$reactstatelyflags = require("@react-stately/flags");
var $kJQf8$reactariai18n = require("@react-aria/i18n");
var $kJQf8$reactstatelycollections = require("@react-stately/collections");
var $kJQf8$reactariafocus = require("@react-aria/focus");
var $kJQf8$reactariainteractions = require("@react-aria/interactions");
var $kJQf8$reactariavisuallyhidden = require("@react-aria/visually-hidden");


function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useTableRowGroup", () => $cd66afe5decb6adb$export$6fb1613bd7b28198);
$parcel$export(module.exports, "useTable", () => $25d14c0f8fad722e$export$25bceaac3c7e4dc7);
$parcel$export(module.exports, "useTableColumnHeader", () => $7669c34a63ef0113$export$9514819a8c81e960);
$parcel$export(module.exports, "useTableRow", () => $10b2115217af7c93$export$7f2f6ae19e707aa5);
$parcel$export(module.exports, "useTableHeaderRow", () => $eb16c38321a72835$export$1b95a7d2d517b841);
$parcel$export(module.exports, "useTableCell", () => $32387a1f2c61cda2$export$49571c903d73624c);
$parcel$export(module.exports, "useTableSelectionCheckbox", () => $0b394e4562ac57c9$export$16ea7f650bd7c1bb);
$parcel$export(module.exports, "useTableSelectAllCheckbox", () => $0b394e4562ac57c9$export$1003db6a7e384b99);
$parcel$export(module.exports, "useTableColumnResize", () => $16d645f9e2153641$export$52994e973806c219);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $6acf696f746f932c$export$552312adfd451dab = new WeakMap();
function $6acf696f746f932c$var$normalizeKey(key) {
    if (typeof key === "string") return key.replace(/\s*/g, "");
    return "" + key;
}
function $6acf696f746f932c$export$37cd4213f2ad742e(state, columnKey) {
    let gridId = $6acf696f746f932c$export$552312adfd451dab.get(state);
    if (!gridId) throw new Error("Unknown grid");
    return `${gridId}-${$6acf696f746f932c$var$normalizeKey(columnKey)}`;
}
function $6acf696f746f932c$export$19baff3266315d44(state, rowKey, columnKey) {
    let gridId = $6acf696f746f932c$export$552312adfd451dab.get(state);
    if (!gridId) throw new Error("Unknown grid");
    return `${gridId}-${$6acf696f746f932c$var$normalizeKey(rowKey)}-${$6acf696f746f932c$var$normalizeKey(columnKey)}`;
}
function $6acf696f746f932c$export$85069b70317f543(state, rowKey) {
    // A row is labelled by it's row headers.
    return [
        ...state.collection.rowHeaderColumnKeys
    ].map((columnKey)=>$6acf696f746f932c$export$19baff3266315d44(state, rowKey, columnKey)).join(" ");
}


var $7ff3f66df3873a5e$exports = {};


































$7ff3f66df3873a5e$exports = {
    "ar-AE": $ca0f93ae476efcee$exports,
    "bg-BG": $8fcf86b24fd399a9$exports,
    "cs-CZ": $146712099a722811$exports,
    "da-DK": $2735c96991aebe53$exports,
    "de-DE": $d85ed0c826146b1e$exports,
    "el-GR": $1aecf8df24cd2c6e$exports,
    "en-US": $8629e38d73986227$exports,
    "es-ES": $219ef73190fd7b54$exports,
    "et-EE": $28e4d12b64c559fe$exports,
    "fi-FI": $d443cdd0bb14863a$exports,
    "fr-FR": $e7b61bd0e93b97c5$exports,
    "he-IL": $b09d12ffa0a56a3e$exports,
    "hr-HR": $c3d9f76f15300329$exports,
    "hu-HU": $9904561a995a328e$exports,
    "it-IT": $b63a88a974650d19$exports,
    "ja-JP": $f79114b6f7838962$exports,
    "ko-KR": $305e358db516b233$exports,
    "lt-LT": $c37a95c245032ee0$exports,
    "lv-LV": $0d99b6662f72a76d$exports,
    "nb-NO": $b350dd154e1c203e$exports,
    "nl-NL": $94dcc10598f2ecbe$exports,
    "pl-PL": $847263ec44d85feb$exports,
    "pt-BR": $649f25af616381b6$exports,
    "pt-PT": $63863f752f22090b$exports,
    "ro-RO": $1011caef6838d0cf$exports,
    "ru-RU": $5c0e71883f016b2f$exports,
    "sk-SK": $9799788df99a536e$exports,
    "sl-SI": $79bf9bea0e0b8579$exports,
    "sr-SP": $374736afc1a4c11c$exports,
    "sv-SE": $948317bce9061901$exports,
    "tr-TR": $73e2289d5a9ac4de$exports,
    "uk-UA": $aca57efccc60ebb1$exports,
    "zh-CN": $ccd86abad329f871$exports,
    "zh-TW": $ad6eb5efb83fe2f8$exports
};




/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

class $a911ff492b884835$export$da43f8f5cb04028d extends (0, $kJQf8$reactariagrid.GridKeyboardDelegate) {
    isCell(node) {
        return node.type === "cell" || node.type === "rowheader" || node.type === "column";
    }
    getKeyBelow(key) {
        let startItem = this.collection.getItem(key);
        if (!startItem) return;
        // If focus was on a column, then focus the first child column if any,
        // or find the corresponding cell in the first row.
        if (startItem.type === "column") {
            let child = (0, $kJQf8$reactstatelycollections.getFirstItem)((0, $kJQf8$reactstatelycollections.getChildNodes)(startItem, this.collection));
            if (child) return child.key;
            let firstKey = this.getFirstKey();
            if (firstKey == null) return;
            let firstItem = this.collection.getItem(firstKey);
            return (0, $kJQf8$reactstatelycollections.getNthItem)((0, $kJQf8$reactstatelycollections.getChildNodes)(firstItem, this.collection), startItem.index).key;
        }
        return super.getKeyBelow(key);
    }
    getKeyAbove(key) {
        let startItem = this.collection.getItem(key);
        if (!startItem) return;
        // If focus was on a column, focus the parent column if any
        if (startItem.type === "column") {
            let parent = this.collection.getItem(startItem.parentKey);
            if (parent && parent.type === "column") return parent.key;
            return;
        }
        // only return above row key if not header row
        let superKey = super.getKeyAbove(key);
        if (superKey != null && this.collection.getItem(superKey).type !== "headerrow") return superKey;
        // If no item was found, and focus was on a cell, then focus the
        // corresponding column header.
        if (this.isCell(startItem)) return this.collection.columns[startItem.index].key;
        // If focus was on a row, then focus the first column header.
        return this.collection.columns[0].key;
    }
    findNextColumnKey(column) {
        // Search following columns
        let key = this.findNextKey(column.key, (item)=>item.type === "column");
        if (key != null) return key;
        // Wrap around to the first column
        let row = this.collection.headerRows[column.level];
        for (let item of (0, $kJQf8$reactstatelycollections.getChildNodes)(row, this.collection)){
            if (item.type === "column") return item.key;
        }
    }
    findPreviousColumnKey(column) {
        // Search previous columns
        let key = this.findPreviousKey(column.key, (item)=>item.type === "column");
        if (key != null) return key;
        // Wrap around to the last column
        let row = this.collection.headerRows[column.level];
        let childNodes = [
            ...(0, $kJQf8$reactstatelycollections.getChildNodes)(row, this.collection)
        ];
        for(let i = childNodes.length - 1; i >= 0; i--){
            let item = childNodes[i];
            if (item.type === "column") return item.key;
        }
    }
    getKeyRightOf(key) {
        let item = this.collection.getItem(key);
        if (!item) return;
        // If focus was on a column, then focus the next column
        if (item.type === "column") return this.direction === "rtl" ? this.findPreviousColumnKey(item) : this.findNextColumnKey(item);
        return super.getKeyRightOf(key);
    }
    getKeyLeftOf(key) {
        let item = this.collection.getItem(key);
        if (!item) return;
        // If focus was on a column, then focus the previous column
        if (item.type === "column") return this.direction === "rtl" ? this.findNextColumnKey(item) : this.findPreviousColumnKey(item);
        return super.getKeyLeftOf(key);
    }
    getKeyForSearch(search, fromKey) {
        if (!this.collator) return null;
        let collection = this.collection;
        let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();
        if (key == null) return null;
        // If the starting key is a cell, search from its parent row.
        let startItem = collection.getItem(key);
        if (startItem.type === "cell") key = startItem.parentKey;
        let hasWrapped = false;
        while(key != null){
            let item = collection.getItem(key);
            // Check each of the row header cells in this row for a match
            for (let cell of (0, $kJQf8$reactstatelycollections.getChildNodes)(item, this.collection)){
                let column = collection.columns[cell.index];
                if (collection.rowHeaderColumnKeys.has(column.key) && cell.textValue) {
                    let substring = cell.textValue.slice(0, search.length);
                    if (this.collator.compare(substring, search) === 0) {
                        // If we started on a cell, end on the matching cell. Otherwise, end on the row.
                        let fromItem = fromKey != null ? collection.getItem(fromKey) : startItem;
                        return fromItem.type === "cell" ? cell.key : item.key;
                    }
                }
            }
            key = this.getKeyBelow(key);
            // Wrap around when reaching the end of the collection
            if (key == null && !hasWrapped) {
                key = this.getFirstKey();
                hasWrapped = true;
            }
        }
        return null;
    }
}




function $25d14c0f8fad722e$export$25bceaac3c7e4dc7(props, state, ref) {
    let { keyboardDelegate: keyboardDelegate, isVirtualized: isVirtualized, layout: layout } = props;
    // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
    // When virtualized, the layout object will be passed in as a prop and override this.
    let collator = (0, $kJQf8$reactariai18n.useCollator)({
        usage: "search",
        sensitivity: "base"
    });
    let { direction: direction } = (0, $kJQf8$reactariai18n.useLocale)();
    let disabledBehavior = state.selectionManager.disabledBehavior;
    let delegate = (0, $kJQf8$react.useMemo)(()=>keyboardDelegate || new (0, $a911ff492b884835$export$da43f8f5cb04028d)({
            collection: state.collection,
            disabledKeys: disabledBehavior === "selection" ? new Set() : state.disabledKeys,
            ref: ref,
            direction: direction,
            collator: collator,
            layout: layout
        }), [
        keyboardDelegate,
        state.collection,
        state.disabledKeys,
        disabledBehavior,
        ref,
        direction,
        collator,
        layout
    ]);
    let id = (0, $kJQf8$reactariautils.useId)(props.id);
    (0, $6acf696f746f932c$export$552312adfd451dab).set(state, id);
    let { gridProps: gridProps } = (0, $kJQf8$reactariagrid.useGrid)({
        ...props,
        id: id,
        keyboardDelegate: delegate
    }, state, ref);
    // Override to include header rows
    if (isVirtualized) gridProps["aria-rowcount"] = state.collection.size + state.collection.headerRows.length;
    if ((0, $kJQf8$reactstatelyflags.tableNestedRows)() && "expandedKeys" in state) gridProps.role = "treegrid";
    let { column: column, direction: sortDirection } = state.sortDescriptor || {};
    let stringFormatter = (0, $kJQf8$reactariai18n.useLocalizedStringFormatter)((0, (/*@__PURE__*/$parcel$interopDefault($7ff3f66df3873a5e$exports))), "@react-aria/table");
    let sortDescription = (0, $kJQf8$react.useMemo)(()=>{
        var _state_collection_columns_find;
        let columnName = (_state_collection_columns_find = state.collection.columns.find((c)=>c.key === column)) === null || _state_collection_columns_find === void 0 ? void 0 : _state_collection_columns_find.textValue;
        return sortDirection && column ? stringFormatter.format(`${sortDirection}Sort`, {
            columnName: columnName
        }) : undefined;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        sortDirection,
        column,
        state.collection.columns
    ]);
    let descriptionProps = (0, $kJQf8$reactariautils.useDescription)(sortDescription);
    // Only announce after initial render, tabbing to the table will tell you the initial sort info already
    (0, $kJQf8$reactariautils.useUpdateEffect)(()=>{
        (0, $kJQf8$reactarialiveannouncer.announce)(sortDescription, "assertive", 500);
    }, [
        sortDescription
    ]);
    return {
        gridProps: (0, $kJQf8$reactariautils.mergeProps)(gridProps, descriptionProps, {
            // merge sort description with long press information
            "aria-describedby": [
                descriptionProps["aria-describedby"],
                gridProps["aria-describedby"]
            ].filter(Boolean).join(" ")
        })
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 







function $7669c34a63ef0113$export$9514819a8c81e960(props, state, ref) {
    var _state_sortDescriptor, _state_sortDescriptor1;
    let { node: node } = props;
    let allowsSorting = node.props.allowsSorting;
    // if there are no focusable children, the column header will focus the cell
    let { gridCellProps: gridCellProps } = (0, $kJQf8$reactariagrid.useGridCell)({
        ...props,
        focusMode: "child"
    }, state, ref);
    let isSelectionCellDisabled = node.props.isSelectionCell && state.selectionManager.selectionMode === "single";
    let { pressProps: pressProps } = (0, $kJQf8$reactariainteractions.usePress)({
        isDisabled: !allowsSorting || isSelectionCellDisabled,
        onPress () {
            state.sort(node.key);
        },
        ref: ref
    });
    // Needed to pick up the focusable context, enabling things like Tooltips for example
    let { focusableProps: focusableProps } = (0, $kJQf8$reactariafocus.useFocusable)({}, ref);
    let ariaSort = null;
    let isSortedColumn = ((_state_sortDescriptor = state.sortDescriptor) === null || _state_sortDescriptor === void 0 ? void 0 : _state_sortDescriptor.column) === node.key;
    let sortDirection = (_state_sortDescriptor1 = state.sortDescriptor) === null || _state_sortDescriptor1 === void 0 ? void 0 : _state_sortDescriptor1.direction;
    // aria-sort not supported in Android Talkback
    if (node.props.allowsSorting && !(0, $kJQf8$reactariautils.isAndroid)()) ariaSort = isSortedColumn ? sortDirection : "none";
    let stringFormatter = (0, $kJQf8$reactariai18n.useLocalizedStringFormatter)((0, (/*@__PURE__*/$parcel$interopDefault($7ff3f66df3873a5e$exports))), "@react-aria/table");
    let sortDescription;
    if (allowsSorting) {
        sortDescription = `${stringFormatter.format("sortable")}`;
        // Android Talkback doesn't support aria-sort so we add sort order details to the aria-described by here
        if (isSortedColumn && sortDirection && (0, $kJQf8$reactariautils.isAndroid)()) sortDescription = `${sortDescription}, ${stringFormatter.format(sortDirection)}`;
    }
    let descriptionProps = (0, $kJQf8$reactariautils.useDescription)(sortDescription);
    let shouldDisableFocus = state.collection.size === 0;
    (0, $kJQf8$react.useEffect)(()=>{
        if (shouldDisableFocus && state.selectionManager.focusedKey === node.key) state.selectionManager.setFocusedKey(null);
    }, [
        shouldDisableFocus,
        state.selectionManager,
        node.key
    ]);
    return {
        columnHeaderProps: {
            ...(0, $kJQf8$reactariautils.mergeProps)(gridCellProps, pressProps, focusableProps, descriptionProps, // If the table is empty, make all column headers untabbable
            shouldDisableFocus && {
                tabIndex: -1
            }),
            role: "columnheader",
            id: (0, $6acf696f746f932c$export$37cd4213f2ad742e)(state, node.key),
            "aria-colspan": node.colspan && node.colspan > 1 ? node.colspan : null,
            "aria-sort": ariaSort
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 





const $10b2115217af7c93$var$EXPANSION_KEYS = {
    expand: {
        ltr: "ArrowRight",
        rtl: "ArrowLeft"
    },
    "collapse": {
        ltr: "ArrowLeft",
        rtl: "ArrowRight"
    }
};
function $10b2115217af7c93$export$7f2f6ae19e707aa5(props, state, ref) {
    let { node: node, isVirtualized: isVirtualized } = props;
    let { rowProps: rowProps, ...states } = (0, $kJQf8$reactariagrid.useGridRow)(props, state, ref);
    let { direction: direction } = (0, $kJQf8$reactariai18n.useLocale)();
    if (isVirtualized && !((0, $kJQf8$reactstatelyflags.tableNestedRows)() && "expandedKeys" in state)) rowProps["aria-rowindex"] = node.index + 1 + state.collection.headerRows.length; // aria-rowindex is 1 based
    else delete rowProps["aria-rowindex"];
    let treeGridRowProps = {};
    if ((0, $kJQf8$reactstatelyflags.tableNestedRows)() && "expandedKeys" in state) {
        let treeNode = state.keyMap.get(node.key);
        if (treeNode != null) {
            var _treeNode_props, _treeNode_props_children, _treeNode_props1;
            let hasChildRows = ((_treeNode_props = treeNode.props) === null || _treeNode_props === void 0 ? void 0 : _treeNode_props.UNSTABLE_childItems) || ((_treeNode_props1 = treeNode.props) === null || _treeNode_props1 === void 0 ? void 0 : (_treeNode_props_children = _treeNode_props1.children) === null || _treeNode_props_children === void 0 ? void 0 : _treeNode_props_children.length) > state.userColumnCount;
            treeGridRowProps = {
                onKeyDown: (e)=>{
                    if (e.key === $10b2115217af7c93$var$EXPANSION_KEYS["expand"][direction] && state.selectionManager.focusedKey === treeNode.key && hasChildRows && state.expandedKeys !== "all" && !state.expandedKeys.has(treeNode.key)) {
                        state.toggleKey(treeNode.key);
                        e.stopPropagation();
                    } else if (e.key === $10b2115217af7c93$var$EXPANSION_KEYS["collapse"][direction] && state.selectionManager.focusedKey === treeNode.key && hasChildRows && (state.expandedKeys === "all" || state.expandedKeys.has(treeNode.key))) {
                        state.toggleKey(treeNode.key);
                        e.stopPropagation();
                    }
                },
                "aria-expanded": hasChildRows ? state.expandedKeys === "all" || state.expandedKeys.has(node.key) : undefined,
                "aria-level": treeNode.level,
                "aria-posinset": treeNode.indexOfType + 1,
                "aria-setsize": treeNode.level > 1 ? (0, $kJQf8$reactstatelycollections.getLastItem)(state.keyMap.get(treeNode === null || treeNode === void 0 ? void 0 : treeNode.parentKey).childNodes).indexOfType + 1 : (0, $kJQf8$reactstatelycollections.getLastItem)(state.keyMap.get(state.collection.body.key).childNodes).indexOfType + 1
            };
        }
    }
    let linkProps = states.hasAction ? (0, $kJQf8$reactariautils.getSyntheticLinkProps)(node.props) : {};
    return {
        rowProps: {
            ...(0, $kJQf8$reactariautils.mergeProps)(rowProps, treeGridRowProps, linkProps),
            "aria-labelledby": (0, $6acf696f746f932c$export$85069b70317f543)(state, node.key)
        },
        ...states
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $eb16c38321a72835$export$1b95a7d2d517b841(props, state, ref) {
    let { node: node, isVirtualized: isVirtualized } = props;
    let rowProps = {
        role: "row"
    };
    if (isVirtualized && !((0, $kJQf8$reactstatelyflags.tableNestedRows)() && "expandedKeys" in state)) rowProps["aria-rowindex"] = node.index + 1; // aria-rowindex is 1 based
    return {
        rowProps: rowProps
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $32387a1f2c61cda2$export$49571c903d73624c(props, state, ref) {
    let { gridCellProps: gridCellProps, isPressed: isPressed } = (0, $kJQf8$reactariagrid.useGridCell)(props, state, ref);
    let columnKey = props.node.column.key;
    if (state.collection.rowHeaderColumnKeys.has(columnKey)) {
        gridCellProps.role = "rowheader";
        gridCellProps.id = (0, $6acf696f746f932c$export$19baff3266315d44)(state, props.node.parentKey, columnKey);
    }
    return {
        gridCellProps: gridCellProps,
        isPressed: isPressed
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



function $0b394e4562ac57c9$export$16ea7f650bd7c1bb(props, state) {
    let { key: key } = props;
    const { checkboxProps: checkboxProps } = (0, $kJQf8$reactariagrid.useGridSelectionCheckbox)(props, state);
    return {
        checkboxProps: {
            ...checkboxProps,
            "aria-labelledby": `${checkboxProps.id} ${(0, $6acf696f746f932c$export$85069b70317f543)(state, key)}`
        }
    };
}
function $0b394e4562ac57c9$export$1003db6a7e384b99(state) {
    let { isEmpty: isEmpty, isSelectAll: isSelectAll, selectionMode: selectionMode } = state.selectionManager;
    const stringFormatter = (0, $kJQf8$reactariai18n.useLocalizedStringFormatter)((0, (/*@__PURE__*/$parcel$interopDefault($7ff3f66df3873a5e$exports))), "@react-aria/table");
    return {
        checkboxProps: {
            "aria-label": stringFormatter.format(selectionMode === "single" ? "select" : "selectAll"),
            isSelected: isSelectAll,
            isDisabled: selectionMode !== "multiple" || state.collection.size === 0,
            isIndeterminate: !isEmpty && !isSelectAll,
            onChange: ()=>state.selectionManager.toggleSelectAll()
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 







function $16d645f9e2153641$export$52994e973806c219(props, state, ref) {
    let { column: item, triggerRef: triggerRef, isDisabled: isDisabled, onResizeStart: onResizeStart, onResize: onResize, onResizeEnd: onResizeEnd, "aria-label": ariaLabel } = props;
    const stringFormatter = (0, $kJQf8$reactariai18n.useLocalizedStringFormatter)((0, (/*@__PURE__*/$parcel$interopDefault($7ff3f66df3873a5e$exports))), "@react-aria/table");
    let id = (0, $kJQf8$reactariautils.useId)();
    let isResizing = state.resizingColumn === item.key;
    let isResizingRef = (0, $kJQf8$react.useRef)(isResizing);
    let lastSize = (0, $kJQf8$react.useRef)(null);
    let wasFocusedOnResizeStart = (0, $kJQf8$react.useRef)(false);
    let editModeEnabled = state.tableState.isKeyboardNavigationDisabled;
    let { direction: direction } = (0, $kJQf8$reactariai18n.useLocale)();
    let { keyboardProps: keyboardProps } = (0, $kJQf8$reactariainteractions.useKeyboard)({
        onKeyDown: (e)=>{
            if (editModeEnabled) {
                if (e.key === "Escape" || e.key === "Enter" || e.key === " " || e.key === "Tab") {
                    e.preventDefault();
                    endResize(item);
                }
            } else {
                // Continue propagation on keydown events so they still bubbles to useSelectableCollection and are handled there
                e.continuePropagation();
                if (e.key === "Enter") startResize(item);
            }
        }
    });
    let startResize = (0, $kJQf8$reactariautils.useEffectEvent)((item)=>{
        if (!isResizingRef.current) {
            lastSize.current = state.updateResizedColumns(item.key, state.getColumnWidth(item.key));
            state.startResize(item.key);
            state.tableState.setKeyboardNavigationDisabled(true);
            onResizeStart === null || onResizeStart === void 0 ? void 0 : onResizeStart(lastSize.current);
        }
        isResizingRef.current = true;
    });
    let resize = (0, $kJQf8$reactariautils.useEffectEvent)((item, newWidth)=>{
        let sizes = state.updateResizedColumns(item.key, newWidth);
        onResize === null || onResize === void 0 ? void 0 : onResize(sizes);
        lastSize.current = sizes;
    });
    let endResize = (0, $kJQf8$reactariautils.useEffectEvent)((item)=>{
        if (isResizingRef.current) {
            if (lastSize.current == null) lastSize.current = state.updateResizedColumns(item.key, state.getColumnWidth(item.key));
            state.endResize();
            state.tableState.setKeyboardNavigationDisabled(false);
            onResizeEnd === null || onResizeEnd === void 0 ? void 0 : onResizeEnd(lastSize.current);
            isResizingRef.current = false;
            if ((triggerRef === null || triggerRef === void 0 ? void 0 : triggerRef.current) && !wasFocusedOnResizeStart.current) // switch focus back to the column header unless the resizer was already focused when resizing started.
            (0, $kJQf8$reactariafocus.focusSafely)(triggerRef.current);
        }
        lastSize.current = null;
    });
    const columnResizeWidthRef = (0, $kJQf8$react.useRef)(0);
    const { moveProps: moveProps } = (0, $kJQf8$reactariainteractions.useMove)({
        onMoveStart () {
            columnResizeWidthRef.current = state.getColumnWidth(item.key);
            startResize(item);
        },
        onMove (e) {
            let { deltaX: deltaX, deltaY: deltaY, pointerType: pointerType } = e;
            if (direction === "rtl") deltaX *= -1;
            if (pointerType === "keyboard") {
                if (deltaY !== 0 && deltaX === 0) deltaX = deltaY * -1;
                deltaX *= 10;
            }
            // if moving up/down only, no need to resize
            if (deltaX !== 0) {
                columnResizeWidthRef.current += deltaX;
                resize(item, columnResizeWidthRef.current);
            }
        },
        onMoveEnd (e) {
            let { pointerType: pointerType } = e;
            columnResizeWidthRef.current = 0;
            if (pointerType === "mouse" || pointerType === "touch" && wasFocusedOnResizeStart.current) endResize(item);
        }
    });
    let onKeyDown = (0, $kJQf8$react.useCallback)((e)=>{
        if (editModeEnabled) moveProps.onKeyDown(e);
    }, [
        editModeEnabled,
        moveProps
    ]);
    let min = Math.floor(state.getColumnMinWidth(item.key));
    let max = Math.floor(state.getColumnMaxWidth(item.key));
    if (max === Infinity) max = Number.MAX_SAFE_INTEGER;
    let value = Math.floor(state.getColumnWidth(item.key));
    let modality = (0, $kJQf8$reactariainteractions.useInteractionModality)();
    if (modality === "virtual" && typeof window !== "undefined" && "ontouchstart" in window) modality = "touch";
    let description = (triggerRef === null || triggerRef === void 0 ? void 0 : triggerRef.current) == null && (modality === "keyboard" || modality === "virtual") && !isResizing ? stringFormatter.format("resizerDescription") : undefined;
    let descriptionProps = (0, $kJQf8$reactariautils.useDescription)(description);
    let ariaProps = {
        "aria-label": ariaLabel,
        "aria-orientation": "horizontal",
        "aria-labelledby": `${id} ${(0, $6acf696f746f932c$export$37cd4213f2ad742e)(state.tableState, item.key)}`,
        "aria-valuetext": stringFormatter.format("columnSize", {
            value: value
        }),
        "type": "range",
        min: min,
        max: max,
        value: value,
        ...descriptionProps
    };
    const focusInput = (0, $kJQf8$react.useCallback)(()=>{
        if (ref.current) (0, $kJQf8$reactariafocus.focusSafely)(ref.current);
    }, [
        ref
    ]);
    let resizingColumn = state.resizingColumn;
    let prevResizingColumn = (0, $kJQf8$react.useRef)(null);
    (0, $kJQf8$react.useEffect)(()=>{
        if (prevResizingColumn.current !== resizingColumn && resizingColumn != null && resizingColumn === item.key) {
            wasFocusedOnResizeStart.current = document.activeElement === ref.current;
            startResize(item);
            // Delay focusing input until Android Chrome's delayed click after touchend happens: https://bugs.chromium.org/p/chromium/issues/detail?id=1150073
            let timeout = setTimeout(()=>focusInput(), 0);
            // VoiceOver on iOS has problems focusing the input from a menu.
            let VOTimeout = setTimeout(focusInput, 400);
            return ()=>{
                clearTimeout(timeout);
                clearTimeout(VOTimeout);
            };
        }
        prevResizingColumn.current = resizingColumn;
    }, [
        resizingColumn,
        item,
        focusInput,
        ref,
        startResize
    ]);
    let onChange = (e)=>{
        let currentWidth = state.getColumnWidth(item.key);
        let nextValue = parseFloat(e.target.value);
        if (nextValue > currentWidth) nextValue = currentWidth + 10;
        else nextValue = currentWidth - 10;
        resize(item, nextValue);
    };
    let { pressProps: pressProps } = (0, $kJQf8$reactariainteractions.usePress)({
        onPressStart: (e)=>{
            if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey || e.pointerType === "keyboard") return;
            if (e.pointerType === "virtual" && state.resizingColumn != null) {
                endResize(item);
                return;
            }
            // Sometimes onPress won't trigger for quick taps on mobile so we want to focus the input so blurring away
            // can cancel resize mode for us.
            focusInput();
            // If resizer is always visible, mobile screenreader user can access the visually hidden resizer directly and thus we don't need
            // to handle a virtual click to start the resizer.
            if (e.pointerType !== "virtual") startResize(item);
        },
        onPress: (e)=>{
            if ((e.pointerType === "touch" && wasFocusedOnResizeStart.current || e.pointerType === "mouse") && state.resizingColumn != null) endResize(item);
        }
    });
    let { visuallyHiddenProps: visuallyHiddenProps } = (0, $kJQf8$reactariavisuallyhidden.useVisuallyHidden)();
    return {
        resizerProps: (0, $kJQf8$reactariautils.mergeProps)(keyboardProps, {
            ...moveProps,
            onKeyDown: onKeyDown
        }, pressProps, {
            style: {
                touchAction: "none"
            }
        }),
        inputProps: (0, $kJQf8$reactariautils.mergeProps)(visuallyHiddenProps, {
            id: id,
            onBlur: ()=>{
                endResize(item);
            },
            onChange: onChange,
            disabled: isDisabled
        }, ariaProps),
        isResizing: isResizing
    };
}



function $cd66afe5decb6adb$export$6fb1613bd7b28198() {
    return (0, $kJQf8$reactariagrid.useGridRowGroup)();
}


//# sourceMappingURL=main.js.map
