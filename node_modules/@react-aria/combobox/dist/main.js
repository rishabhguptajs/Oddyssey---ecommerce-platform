var $a756282ae45b5180$exports = require("./ar-AE.main.js");
var $50569559b1387c57$exports = require("./bg-BG.main.js");
var $bff243ee21f5616f$exports = require("./cs-CZ.main.js");
var $1508d10b8eb2180a$exports = require("./da-DK.main.js");
var $aa4e6d422b8a72e9$exports = require("./de-DE.main.js");
var $b88e038b0dd4dc0a$exports = require("./el-GR.main.js");
var $dbcec05b5ddcd323$exports = require("./en-US.main.js");
var $3a762c75d410ecfe$exports = require("./es-ES.main.js");
var $345540ad7e1ca6bf$exports = require("./et-EE.main.js");
var $f314257d456879ad$exports = require("./fi-FI.main.js");
var $ebebc2f5e8da1157$exports = require("./fr-FR.main.js");
var $3dda6220a904406b$exports = require("./he-IL.main.js");
var $21178dd033a9f6f2$exports = require("./hr-HR.main.js");
var $f12e9cac54fcde83$exports = require("./hu-HU.main.js");
var $c7ad5d19d847ae9c$exports = require("./it-IT.main.js");
var $2cd660cb05523578$exports = require("./ja-JP.main.js");
var $854156a4c27f569c$exports = require("./ko-KR.main.js");
var $dabe6c727809b774$exports = require("./lt-LT.main.js");
var $7810eacb77cdba0d$exports = require("./lv-LV.main.js");
var $5e329fda39bb6d70$exports = require("./nb-NO.main.js");
var $29be2a564837167c$exports = require("./nl-NL.main.js");
var $7c0ffa214495a56b$exports = require("./pl-PL.main.js");
var $e8665834548c9563$exports = require("./pt-BR.main.js");
var $3f614fe48e86ff5a$exports = require("./pt-PT.main.js");
var $e7efe9ced5993d70$exports = require("./ro-RO.main.js");
var $d56743931b3be207$exports = require("./ru-RU.main.js");
var $68a40ce74b5b67bf$exports = require("./sk-SK.main.js");
var $58f7d43d88008c7d$exports = require("./sl-SI.main.js");
var $914aa7442fad912d$exports = require("./sr-SP.main.js");
var $85af38f91b727899$exports = require("./sv-SE.main.js");
var $72a40ca4dde96679$exports = require("./tr-TR.main.js");
var $300dce19c9e0d13f$exports = require("./uk-UA.main.js");
var $015ff4188b7f78eb$exports = require("./zh-CN.main.js");
var $713552ac3e0ac749$exports = require("./zh-TW.main.js");
var $8Zqhq$reactarialiveannouncer = require("@react-aria/live-announcer");
var $8Zqhq$reactariaoverlays = require("@react-aria/overlays");
var $8Zqhq$reactarialistbox = require("@react-aria/listbox");
var $8Zqhq$reactariautils = require("@react-aria/utils");
var $8Zqhq$react = require("react");
var $8Zqhq$reactstatelycollections = require("@react-stately/collections");
var $8Zqhq$reactariaselection = require("@react-aria/selection");
var $8Zqhq$reactstatelyform = require("@react-stately/form");
var $8Zqhq$reactariai18n = require("@react-aria/i18n");
var $8Zqhq$reactariamenu = require("@react-aria/menu");
var $8Zqhq$reactariatextfield = require("@react-aria/textfield");


function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useComboBox", () => $242452271d1e4c0e$export$8c18d1b4f7232bbf);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 





var $8d1e5da058b86bb9$exports = {};


































$8d1e5da058b86bb9$exports = {
    "ar-AE": $a756282ae45b5180$exports,
    "bg-BG": $50569559b1387c57$exports,
    "cs-CZ": $bff243ee21f5616f$exports,
    "da-DK": $1508d10b8eb2180a$exports,
    "de-DE": $aa4e6d422b8a72e9$exports,
    "el-GR": $b88e038b0dd4dc0a$exports,
    "en-US": $dbcec05b5ddcd323$exports,
    "es-ES": $3a762c75d410ecfe$exports,
    "et-EE": $345540ad7e1ca6bf$exports,
    "fi-FI": $f314257d456879ad$exports,
    "fr-FR": $ebebc2f5e8da1157$exports,
    "he-IL": $3dda6220a904406b$exports,
    "hr-HR": $21178dd033a9f6f2$exports,
    "hu-HU": $f12e9cac54fcde83$exports,
    "it-IT": $c7ad5d19d847ae9c$exports,
    "ja-JP": $2cd660cb05523578$exports,
    "ko-KR": $854156a4c27f569c$exports,
    "lt-LT": $dabe6c727809b774$exports,
    "lv-LV": $7810eacb77cdba0d$exports,
    "nb-NO": $5e329fda39bb6d70$exports,
    "nl-NL": $29be2a564837167c$exports,
    "pl-PL": $7c0ffa214495a56b$exports,
    "pt-BR": $e8665834548c9563$exports,
    "pt-PT": $3f614fe48e86ff5a$exports,
    "ro-RO": $e7efe9ced5993d70$exports,
    "ru-RU": $d56743931b3be207$exports,
    "sk-SK": $68a40ce74b5b67bf$exports,
    "sl-SI": $58f7d43d88008c7d$exports,
    "sr-SP": $914aa7442fad912d$exports,
    "sv-SE": $85af38f91b727899$exports,
    "tr-TR": $72a40ca4dde96679$exports,
    "uk-UA": $300dce19c9e0d13f$exports,
    "zh-CN": $015ff4188b7f78eb$exports,
    "zh-TW": $713552ac3e0ac749$exports
};







function $242452271d1e4c0e$export$8c18d1b4f7232bbf(props, state) {
    let { buttonRef: buttonRef, popoverRef: popoverRef, inputRef: inputRef, listBoxRef: listBoxRef, keyboardDelegate: keyboardDelegate, shouldFocusWrap: // completionMode = 'suggest',
    shouldFocusWrap, isReadOnly: isReadOnly, isDisabled: isDisabled } = props;
    let stringFormatter = (0, $8Zqhq$reactariai18n.useLocalizedStringFormatter)((0, (/*@__PURE__*/$parcel$interopDefault($8d1e5da058b86bb9$exports))), "@react-aria/combobox");
    let { menuTriggerProps: menuTriggerProps, menuProps: menuProps } = (0, $8Zqhq$reactariamenu.useMenuTrigger)({
        type: "listbox",
        isDisabled: isDisabled || isReadOnly
    }, state, buttonRef);
    // Set listbox id so it can be used when calling getItemId later
    (0, $8Zqhq$reactarialistbox.listData).set(state, {
        id: menuProps.id
    });
    // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
    // When virtualized, the layout object will be passed in as a prop and override this.
    let delegate = (0, $8Zqhq$react.useMemo)(()=>keyboardDelegate || new (0, $8Zqhq$reactariaselection.ListKeyboardDelegate)(state.collection, state.disabledKeys, listBoxRef), [
        keyboardDelegate,
        state.collection,
        state.disabledKeys,
        listBoxRef
    ]);
    // Use useSelectableCollection to get the keyboard handlers to apply to the textfield
    let { collectionProps: collectionProps } = (0, $8Zqhq$reactariaselection.useSelectableCollection)({
        selectionManager: state.selectionManager,
        keyboardDelegate: delegate,
        disallowTypeAhead: true,
        disallowEmptySelection: true,
        shouldFocusWrap: shouldFocusWrap,
        ref: inputRef,
        // Prevent item scroll behavior from being applied here, should be handled in the user's Popover + ListBox component
        isVirtualized: true
    });
    let router = (0, $8Zqhq$reactariautils.useRouter)();
    // For textfield specific keydown operations
    let onKeyDown = (e)=>{
        switch(e.key){
            case "Enter":
            case "Tab":
                // Prevent form submission if menu is open since we may be selecting a option
                if (state.isOpen && e.key === "Enter") e.preventDefault();
                // If the focused item is a link, trigger opening it. Items that are links are not selectable.
                if (state.isOpen && state.selectionManager.focusedKey != null && state.selectionManager.isLink(state.selectionManager.focusedKey)) {
                    if (e.key === "Enter") {
                        let item = listBoxRef.current.querySelector(`[data-key="${CSS.escape(state.selectionManager.focusedKey.toString())}"]`);
                        if (item instanceof HTMLAnchorElement) router.open(item, e);
                    }
                    state.close();
                } else state.commit();
                break;
            case "Escape":
                if (state.selectedKey !== null || state.inputValue === "" || props.allowsCustomValue) e.continuePropagation();
                state.revert();
                break;
            case "ArrowDown":
                state.open("first", "manual");
                break;
            case "ArrowUp":
                state.open("last", "manual");
                break;
            case "ArrowLeft":
            case "ArrowRight":
                state.selectionManager.setFocusedKey(null);
                break;
        }
    };
    let onBlur = (e)=>{
        var _popoverRef_current;
        // Ignore blur if focused moved to the button or into the popover.
        if (e.relatedTarget === (buttonRef === null || buttonRef === void 0 ? void 0 : buttonRef.current) || ((_popoverRef_current = popoverRef.current) === null || _popoverRef_current === void 0 ? void 0 : _popoverRef_current.contains(e.relatedTarget))) return;
        if (props.onBlur) props.onBlur(e);
        state.setFocused(false);
    };
    let onFocus = (e)=>{
        if (state.isFocused) return;
        if (props.onFocus) props.onFocus(e);
        state.setFocused(true);
    };
    let { isInvalid: isInvalid, validationErrors: validationErrors, validationDetails: validationDetails } = state.displayValidation;
    let { labelProps: labelProps, inputProps: inputProps, descriptionProps: descriptionProps, errorMessageProps: errorMessageProps } = (0, $8Zqhq$reactariatextfield.useTextField)({
        ...props,
        onChange: state.setInputValue,
        onKeyDown: !isReadOnly ? (0, $8Zqhq$reactariautils.chain)(state.isOpen && collectionProps.onKeyDown, onKeyDown, props.onKeyDown) : props.onKeyDown,
        onBlur: onBlur,
        value: state.inputValue,
        onFocus: onFocus,
        autoComplete: "off",
        validate: undefined,
        [(0, $8Zqhq$reactstatelyform.privateValidationStateProp)]: state
    }, inputRef);
    // Press handlers for the ComboBox button
    let onPress = (e)=>{
        if (e.pointerType === "touch") {
            // Focus the input field in case it isn't focused yet
            inputRef.current.focus();
            state.toggle(null, "manual");
        }
    };
    let onPressStart = (e)=>{
        if (e.pointerType !== "touch") {
            inputRef.current.focus();
            state.toggle(e.pointerType === "keyboard" || e.pointerType === "virtual" ? "first" : null, "manual");
        }
    };
    let triggerLabelProps = (0, $8Zqhq$reactariautils.useLabels)({
        id: menuTriggerProps.id,
        "aria-label": stringFormatter.format("buttonLabel"),
        "aria-labelledby": props["aria-labelledby"] || labelProps.id
    });
    let listBoxProps = (0, $8Zqhq$reactariautils.useLabels)({
        id: menuProps.id,
        "aria-label": stringFormatter.format("listboxLabel"),
        "aria-labelledby": props["aria-labelledby"] || labelProps.id
    });
    // If a touch happens on direct center of ComboBox input, might be virtual click from iPad so open ComboBox menu
    let lastEventTime = (0, $8Zqhq$react.useRef)(0);
    let onTouchEnd = (e)=>{
        if (isDisabled || isReadOnly) return;
        // Sometimes VoiceOver on iOS fires two touchend events in quick succession. Ignore the second one.
        if (e.timeStamp - lastEventTime.current < 500) {
            e.preventDefault();
            inputRef.current.focus();
            return;
        }
        let rect = e.target.getBoundingClientRect();
        let touch = e.changedTouches[0];
        let centerX = Math.ceil(rect.left + .5 * rect.width);
        let centerY = Math.ceil(rect.top + .5 * rect.height);
        if (touch.clientX === centerX && touch.clientY === centerY) {
            e.preventDefault();
            inputRef.current.focus();
            state.toggle(null, "manual");
            lastEventTime.current = e.timeStamp;
        }
    };
    // VoiceOver has issues with announcing aria-activedescendant properly on change
    // (especially on iOS). We use a live region announcer to announce focus changes
    // manually. In addition, section titles are announced when navigating into a new section.
    let focusedItem = state.selectionManager.focusedKey != null && state.isOpen ? state.collection.getItem(state.selectionManager.focusedKey) : undefined;
    var _focusedItem_parentKey;
    let sectionKey = (_focusedItem_parentKey = focusedItem === null || focusedItem === void 0 ? void 0 : focusedItem.parentKey) !== null && _focusedItem_parentKey !== void 0 ? _focusedItem_parentKey : null;
    var _state_selectionManager_focusedKey;
    let itemKey = (_state_selectionManager_focusedKey = state.selectionManager.focusedKey) !== null && _state_selectionManager_focusedKey !== void 0 ? _state_selectionManager_focusedKey : null;
    let lastSection = (0, $8Zqhq$react.useRef)(sectionKey);
    let lastItem = (0, $8Zqhq$react.useRef)(itemKey);
    (0, $8Zqhq$react.useEffect)(()=>{
        if ((0, $8Zqhq$reactariautils.isAppleDevice)() && focusedItem != null && itemKey !== lastItem.current) {
            let isSelected = state.selectionManager.isSelected(itemKey);
            let section = sectionKey != null ? state.collection.getItem(sectionKey) : null;
            let sectionTitle = (section === null || section === void 0 ? void 0 : section["aria-label"]) || (typeof (section === null || section === void 0 ? void 0 : section.rendered) === "string" ? section.rendered : "") || "";
            let announcement = stringFormatter.format("focusAnnouncement", {
                isGroupChange: section && sectionKey !== lastSection.current,
                groupTitle: sectionTitle,
                groupCount: section ? [
                    ...(0, $8Zqhq$reactstatelycollections.getChildNodes)(section, state.collection)
                ].length : 0,
                optionText: focusedItem["aria-label"] || focusedItem.textValue || "",
                isSelected: isSelected
            });
            (0, $8Zqhq$reactarialiveannouncer.announce)(announcement);
        }
        lastSection.current = sectionKey;
        lastItem.current = itemKey;
    });
    // Announce the number of available suggestions when it changes
    let optionCount = (0, $8Zqhq$reactstatelycollections.getItemCount)(state.collection);
    let lastSize = (0, $8Zqhq$react.useRef)(optionCount);
    let lastOpen = (0, $8Zqhq$react.useRef)(state.isOpen);
    (0, $8Zqhq$react.useEffect)(()=>{
        // Only announce the number of options available when the menu opens if there is no
        // focused item, otherwise screen readers will typically read e.g. "1 of 6".
        // The exception is VoiceOver since this isn't included in the message above.
        let didOpenWithoutFocusedItem = state.isOpen !== lastOpen.current && (state.selectionManager.focusedKey == null || (0, $8Zqhq$reactariautils.isAppleDevice)());
        if (state.isOpen && (didOpenWithoutFocusedItem || optionCount !== lastSize.current)) {
            let announcement = stringFormatter.format("countAnnouncement", {
                optionCount: optionCount
            });
            (0, $8Zqhq$reactarialiveannouncer.announce)(announcement);
        }
        lastSize.current = optionCount;
        lastOpen.current = state.isOpen;
    });
    // Announce when a selection occurs for VoiceOver. Other screen readers typically do this automatically.
    let lastSelectedKey = (0, $8Zqhq$react.useRef)(state.selectedKey);
    (0, $8Zqhq$react.useEffect)(()=>{
        if ((0, $8Zqhq$reactariautils.isAppleDevice)() && state.isFocused && state.selectedItem && state.selectedKey !== lastSelectedKey.current) {
            let optionText = state.selectedItem["aria-label"] || state.selectedItem.textValue || "";
            let announcement = stringFormatter.format("selectedAnnouncement", {
                optionText: optionText
            });
            (0, $8Zqhq$reactarialiveannouncer.announce)(announcement);
        }
        lastSelectedKey.current = state.selectedKey;
    });
    (0, $8Zqhq$react.useEffect)(()=>{
        if (state.isOpen) return (0, $8Zqhq$reactariaoverlays.ariaHideOutside)([
            inputRef.current,
            popoverRef.current
        ]);
    }, [
        state.isOpen,
        inputRef,
        popoverRef
    ]);
    return {
        labelProps: labelProps,
        buttonProps: {
            ...menuTriggerProps,
            ...triggerLabelProps,
            excludeFromTabOrder: true,
            onPress: onPress,
            onPressStart: onPressStart,
            isDisabled: isDisabled || isReadOnly
        },
        inputProps: (0, $8Zqhq$reactariautils.mergeProps)(inputProps, {
            role: "combobox",
            "aria-expanded": menuTriggerProps["aria-expanded"],
            "aria-controls": state.isOpen ? menuProps.id : undefined,
            // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)
            "aria-autocomplete": "list",
            "aria-activedescendant": focusedItem ? (0, $8Zqhq$reactarialistbox.getItemId)(state, focusedItem.key) : undefined,
            onTouchEnd: onTouchEnd,
            // This disable's iOS's autocorrect suggestions, since the combo box provides its own suggestions.
            autoCorrect: "off",
            // This disable's the macOS Safari spell check auto corrections.
            spellCheck: "false"
        }),
        listBoxProps: (0, $8Zqhq$reactariautils.mergeProps)(menuProps, listBoxProps, {
            autoFocus: state.focusStrategy,
            shouldUseVirtualFocus: true,
            shouldSelectOnPressUp: true,
            shouldFocusOnHover: true,
            linkBehavior: "selection"
        }),
        descriptionProps: descriptionProps,
        errorMessageProps: errorMessageProps,
        isInvalid: isInvalid,
        validationErrors: validationErrors,
        validationDetails: validationDetails
    };
}




//# sourceMappingURL=main.js.map
